{"ast":null,"code":"/**\n * @author Kuitos\n * @since 2020-04-13\n */\nimport { isBoundedFunction, isCallable, isConstructable } from '../utils';\nvar currentRunningApp = null;\n/**\n * get the app that running tasks at current tick\n */\nexport function getCurrentRunningApp() {\n  return currentRunningApp;\n}\nexport function setCurrentRunningApp(appInstance) {\n  // Set currentRunningApp and it's proxySandbox to global window, as its only use case is for document.createElement from now on, which hijacked by a global way\n  currentRunningApp = appInstance;\n}\nexport function clearCurrentRunningApp() {\n  currentRunningApp = null;\n}\nvar functionBoundedValueMap = new WeakMap();\nexport function rebindTarget2Fn(target, fn) {\n  /*\n    仅绑定 isCallable && !isBoundedFunction && !isConstructable 的函数对象，如 window.console、window.atob 这类，不然微应用中调用时会抛出 Illegal invocation 异常\n    目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断\n    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）\n   */\n  if (isCallable(fn) && !isBoundedFunction(fn) && !isConstructable(fn)) {\n    var cachedBoundFunction = functionBoundedValueMap.get(fn);\n    if (cachedBoundFunction) {\n      return cachedBoundFunction;\n    }\n    var boundValue = Function.prototype.bind.call(fn, target);\n    // some callable function has custom fields, we need to copy the own props to boundValue. such as moment function.\n    Object.getOwnPropertyNames(fn).forEach(function (key) {\n      // boundValue might be a proxy, we need to check the key whether exist in it\n      if (!boundValue.hasOwnProperty(key)) {\n        Object.defineProperty(boundValue, key, Object.getOwnPropertyDescriptor(fn, key));\n      }\n    });\n    // copy prototype if bound function not have but target one have\n    // as prototype is non-enumerable mostly, we need to copy it from target function manually\n    if (fn.hasOwnProperty('prototype') && !boundValue.hasOwnProperty('prototype')) {\n      // we should not use assignment operator to set boundValue prototype like `boundValue.prototype = fn.prototype`\n      // as the assignment will also look up prototype chain while it hasn't own prototype property,\n      // when the lookup succeed, the assignment will throw an TypeError like `Cannot assign to read only property 'prototype' of function` if its descriptor configured with writable false or just have a getter accessor\n      // see https://github.com/umijs/qiankun/issues/1121\n      Object.defineProperty(boundValue, 'prototype', {\n        value: fn.prototype,\n        enumerable: false,\n        writable: true\n      });\n    }\n    // Some util, like `function isNative() {  return typeof Ctor === 'function' && /native code/.test(Ctor.toString()) }` relies on the original `toString()` result\n    // but bound functions will always return \"function() {[native code]}\" for `toString`, which is misleading\n    if (typeof fn.toString === 'function') {\n      var valueHasInstanceToString = fn.hasOwnProperty('toString') && !boundValue.hasOwnProperty('toString');\n      var boundValueHasPrototypeToString = boundValue.toString === Function.prototype.toString;\n      if (valueHasInstanceToString || boundValueHasPrototypeToString) {\n        var originToStringDescriptor = Object.getOwnPropertyDescriptor(valueHasInstanceToString ? fn : Function.prototype, 'toString');\n        Object.defineProperty(boundValue, 'toString', Object.assign({}, originToStringDescriptor, (originToStringDescriptor === null || originToStringDescriptor === void 0 ? void 0 : originToStringDescriptor.get) ? null : {\n          value: function value() {\n            return fn.toString();\n          }\n        }));\n      }\n    }\n    functionBoundedValueMap.set(fn, boundValue);\n    return boundValue;\n  }\n  return fn;\n}","map":{"version":3,"names":["isBoundedFunction","isCallable","isConstructable","currentRunningApp","getCurrentRunningApp","setCurrentRunningApp","appInstance","clearCurrentRunningApp","functionBoundedValueMap","WeakMap","rebindTarget2Fn","target","fn","cachedBoundFunction","get","boundValue","Function","prototype","bind","call","Object","getOwnPropertyNames","forEach","key","hasOwnProperty","defineProperty","getOwnPropertyDescriptor","value","enumerable","writable","toString","valueHasInstanceToString","boundValueHasPrototypeToString","originToStringDescriptor","assign","set"],"sources":["/home/lishu/桌面/Micro_frontend_practice/qiankun_micro/qiankun-base/node_modules/qiankun/es/sandbox/common.js"],"sourcesContent":["/**\n * @author Kuitos\n * @since 2020-04-13\n */\nimport { isBoundedFunction, isCallable, isConstructable } from '../utils';\nvar currentRunningApp = null;\n/**\n * get the app that running tasks at current tick\n */\nexport function getCurrentRunningApp() {\n  return currentRunningApp;\n}\nexport function setCurrentRunningApp(appInstance) {\n  // Set currentRunningApp and it's proxySandbox to global window, as its only use case is for document.createElement from now on, which hijacked by a global way\n  currentRunningApp = appInstance;\n}\nexport function clearCurrentRunningApp() {\n  currentRunningApp = null;\n}\nvar functionBoundedValueMap = new WeakMap();\nexport function rebindTarget2Fn(target, fn) {\n  /*\n    仅绑定 isCallable && !isBoundedFunction && !isConstructable 的函数对象，如 window.console、window.atob 这类，不然微应用中调用时会抛出 Illegal invocation 异常\n    目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断\n    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）\n   */\n  if (isCallable(fn) && !isBoundedFunction(fn) && !isConstructable(fn)) {\n    var cachedBoundFunction = functionBoundedValueMap.get(fn);\n    if (cachedBoundFunction) {\n      return cachedBoundFunction;\n    }\n    var boundValue = Function.prototype.bind.call(fn, target);\n    // some callable function has custom fields, we need to copy the own props to boundValue. such as moment function.\n    Object.getOwnPropertyNames(fn).forEach(function (key) {\n      // boundValue might be a proxy, we need to check the key whether exist in it\n      if (!boundValue.hasOwnProperty(key)) {\n        Object.defineProperty(boundValue, key, Object.getOwnPropertyDescriptor(fn, key));\n      }\n    });\n    // copy prototype if bound function not have but target one have\n    // as prototype is non-enumerable mostly, we need to copy it from target function manually\n    if (fn.hasOwnProperty('prototype') && !boundValue.hasOwnProperty('prototype')) {\n      // we should not use assignment operator to set boundValue prototype like `boundValue.prototype = fn.prototype`\n      // as the assignment will also look up prototype chain while it hasn't own prototype property,\n      // when the lookup succeed, the assignment will throw an TypeError like `Cannot assign to read only property 'prototype' of function` if its descriptor configured with writable false or just have a getter accessor\n      // see https://github.com/umijs/qiankun/issues/1121\n      Object.defineProperty(boundValue, 'prototype', {\n        value: fn.prototype,\n        enumerable: false,\n        writable: true\n      });\n    }\n    // Some util, like `function isNative() {  return typeof Ctor === 'function' && /native code/.test(Ctor.toString()) }` relies on the original `toString()` result\n    // but bound functions will always return \"function() {[native code]}\" for `toString`, which is misleading\n    if (typeof fn.toString === 'function') {\n      var valueHasInstanceToString = fn.hasOwnProperty('toString') && !boundValue.hasOwnProperty('toString');\n      var boundValueHasPrototypeToString = boundValue.toString === Function.prototype.toString;\n      if (valueHasInstanceToString || boundValueHasPrototypeToString) {\n        var originToStringDescriptor = Object.getOwnPropertyDescriptor(valueHasInstanceToString ? fn : Function.prototype, 'toString');\n        Object.defineProperty(boundValue, 'toString', Object.assign({}, originToStringDescriptor, (originToStringDescriptor === null || originToStringDescriptor === void 0 ? void 0 : originToStringDescriptor.get) ? null : {\n          value: function value() {\n            return fn.toString();\n          }\n        }));\n      }\n    }\n    functionBoundedValueMap.set(fn, boundValue);\n    return boundValue;\n  }\n  return fn;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}